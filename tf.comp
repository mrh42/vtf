#version 460
//#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_gpu_shader_int64 : enable
//#extension GL_EXT_debug_printf : enable
//#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : enable
//#extension GL_EXT_shader_explicit_arithmetic_types_int16 : enable
//#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable


//
// compile this file with: glslangValidator --target-env vulkan1.3 -V tf.comp
// or glslc --target-env=vulkan1.3 tf.comp
//
// Installing the 'vulkan-amdgpu' package will result in a significant (2.5x) performance increase.
//

// each thread will consider this many k values
#define NK 300

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// for speed, we only have space to return one found factor.  In the case of P with multiple close factors,
// which could be found in the same invocation, these will write over each other.  Since we might have 512K threads
// looking at hundreds of factors each, we don't want to allocate memory to avoid this.  So we'll learn of a
// factor, but not all of the found factors.
layout(binding = 0) buffer buf
{	
	readonly uint64_t    P;       // input from CPU side
	readonly uint64_t    K;       // base K input from CPU side
	uint64_t    Found;   // output to tell the CPU we found a K resulting in a factor
	uint64_t    Debug[2];     // output only used for debugging
	readonly uint        Init;    // If this is 0, then we setup our tables once.
	uint        k4620[4620][4620];  // GPU generates this during init=0 call
};



struct uint128 {
	uint64_t Hi, Lo;
};
struct uint256 {
	uint128 H, L;
};
struct uint192 {
	uint64_t H;
	uint128 L;
};

void Set(inout uint256 A, uint128 B) {
	A.L = B;
	A.H.Lo = 0;
	A.H.Hi = 0;
}
void Lsh(inout uint128 A) {
	uint64_t c = A.Lo & (uint64_t(1) << 63);
	A.Lo <<= 1;
	A.Hi <<= 1;
	A.Hi |= c >> 63;
}
void Lsh(inout uint256 A) {
	
	uint64_t c = A.L.Hi & (uint64_t(1) << 63);
	Lsh(A.L);
	Lsh(A.H);
	A.H.Lo |= c >> 63;
}
void Lsh(inout uint192 A) {
	
	uint64_t c = A.L.Hi & (uint64_t(1) << 63);
	Lsh(A.L);
	A.H <<= 1;
	A.H |= c >> 63;
}

void Rsh(inout uint128 A) {
	uint64_t b = A.Hi & 1l;
	A.Hi >>= 1;
	A.Lo >>= 1;
	A.Lo |= b << 63;
}
void Rsh(inout uint256 A) {
	Rsh(A.L);
	uint64_t b = A.H.Lo & 1l;
	Rsh(A.H);
	A.L.Hi |= b << 63;
	
}
int Cmp(uint128 A, uint128 B) {
	if (A.Hi > B.Hi || (A.Hi == B.Hi && A.Lo > B.Lo)) {return 1;}
	if (A.Hi < B.Hi || (A.Hi == B.Hi && A.Lo < B.Lo)) {return -1;}
	return 0;
}
int Cmp(uint192 A, uint128 B) {
	if (A.H != 0) {
		return 1;
	}
	return Cmp(A.L, B);
}
int Cmp(uint256 A, uint128 B) {
	if (A.H.Hi != 0 || A.H.Lo != 0) {
		return 1;
	}
	return Cmp(A.L, B);
}
int Cmp(uint256 A, uint256 B) {
	int d = Cmp(A.H, B.H);
	if (d != 0) { return d; }
	return Cmp(A.L, B.L);
}
void Inc(inout uint128 A) {
	A.Lo += 1;
	if (A.Lo == 0) {
		A.Hi += 1;
	}
}
void Sub(inout uint128 A, uint128 B) {
	uint64_t x = A.Lo - B.Lo;
	uint64_t C = (((x & B.Lo) & 1l) + (B.Lo >> 1) + (x >> 1)) >> 63;
	A.Hi = A.Hi - (B.Hi + C);
	A.Lo = x;
}
void Sub(inout uint256 A, uint256 B) {
	uint64_t x = A.L.Lo - B.L.Lo;
	uint C = 0;
	if (x > A.L.Lo) {C++;}
	A.L.Lo = x;
	x = A.L.Hi - (B.L.Hi + C);
	C = 0;
	if (x > A.L.Hi) {C++;} 
	A.L.Hi = x;

	x = A.H.Lo - (B.H.Lo + C);
	C = 0;
	if (x > A.H.Lo) {C++;}
	A.H.Lo = x;

	A.H.Hi = A.H.Hi - (B.H.Hi + C);
}
void Sub(inout uint192 A, uint192 B) {
	uint64_t x = A.L.Lo - B.L.Lo;
	uint C = 0;
	if (x > A.L.Lo) {C++;}
	A.L.Lo = x;
	x = A.L.Hi - (B.L.Hi + C);
	C = 0;
	if (x > A.L.Hi) {C++;} 
	A.L.Hi = x;

	A.H = A.H - (B.H + C);
}
void Add(inout uint128 A, uint128 B) {
	uint64_t x = A.Lo + B.Lo;
	uint64_t C = 0;
	if (x < A.Lo) {C++;}
	A.Hi = A.Hi + (B.Hi + C);
	A.Lo = x;
}
bool Zero(uint128 A) {
	return A.Lo == 0 && A.Hi == 0;
}
//
// Used to compute Q = 2*P*K+1 for each K, and for the 256 multiplies below.
//
void multiply64to128(uint64_t lhs, uint64_t rhs, inout uint128 r) {

	/* First calculate all of the cross products. */
	uint64_t lo_lo = (lhs & 0xFFFFFFFFul) * (rhs & 0xFFFFFFFFul);
	uint64_t hi_lo = (lhs >> 32)        * (rhs & 0xFFFFFFFFul);
	uint64_t lo_hi = (lhs & 0xFFFFFFFFul) * (rhs >> 32);
	uint64_t hi_hi = (lhs >> 32)        * (rhs >> 32);

	/* Now add the products together. These will never overflow. */
	uint64_t cross = (lo_lo >> 32) + (hi_lo & 0xFFFFFFFFul) + lo_hi;
	uint64_t upper = (hi_lo >> 32) + (cross >> 32)        + hi_hi;

	r.Hi = upper;
	r.Lo = (cross << 32) | (lo_lo & 0xFFFFFFFFul);
}

void Sq256(uint128 A, inout uint256 X) {
	multiply64to128(A.Hi, A.Hi, X.H);
	multiply64to128(A.Lo, A.Lo, X.L);

	uint128 T;
	multiply64to128(A.Hi, A.Lo, T);
	Lsh(T);

	X.L.Hi += T.Lo;
	if (X.L.Hi < T.Lo) {
		Inc(X.H);
	}
	X.H.Lo += T.Hi;
	if (X.H.Lo < T.Hi) {
		X.H.Hi++;
	}
}
void Sq192(uint128 A, inout uint192 X) {	
	X.H = A.Hi * A.Hi;
	multiply64to128(A.Lo, A.Lo, X.L);

	uint128 T;
	multiply64to128(A.Hi, A.Lo, T);
	Lsh(T);

	X.L.Hi += T.Lo;
	if (X.L.Hi < T.Lo) {
		X.H++;
	}
	X.H += T.Hi;
}
void Mul192(uint128 A, uint128 B, inout uint192 X) {
	X.H = A.Hi * B.Hi;
	multiply64to128(A.Lo, B.Lo, X.L);

	uint128 T;
	multiply64to128(B.Hi, A.Lo, T);

	X.L.Hi += T.Lo;
	if (X.L.Hi < T.Lo) {
		X.H++;
	}
	X.H += T.Hi;

	multiply64to128(A.Hi, B.Lo, T);

	X.L.Hi += T.Lo;
	if (X.L.Hi < T.Lo) {
		X.H++;
	}
	X.H += T.Hi;
}
void Mul256(uint128 A, uint128 B, inout uint256 X) {
	multiply64to128(A.Hi, B.Hi, X.H);
	multiply64to128(A.Lo, B.Lo, X.L);

	uint128 T;
	multiply64to128(B.Hi, A.Lo, T);

	X.L.Hi += T.Lo;
	if (X.L.Hi < T.Lo) {
		Inc(X.H);
	}
	X.H.Lo += T.Hi;
	if (X.H.Lo < T.Hi) {
		X.H.Hi++;
	}

	multiply64to128(A.Hi, B.Lo, T);

	X.L.Hi += T.Lo;
	if (X.L.Hi < T.Lo) {
		Inc(X.H);
	}
	X.H.Lo += T.Hi;
	if (X.H.Lo < T.Hi) {
		X.H.Hi++;
	}
}


// 2^64, 2^128 and 2^192
const 	double p64 =  18446744073709551616.0lf;
const	double p128 = 340282366920938463463374607431768211456.0lf;
const	double p192 = 6277101735386680763835789423207666416102355444464034512896.0lf;

double toF(uint128 A) {
	return double(A.Lo) + double(A.Hi) * p64;
}
double toF(uint192 A) {

	return double(A.L.Lo) + double(A.L.Hi)*p64 + double(A.H)*p128;
}
double toF(uint256 A) {

	return double(A.L.Lo) + double(A.L.Hi)*p64 + double(A.H.Lo)*p128 + double(A.H.Hi)*p192;
}
void fto128(double f, out uint128 A) {
	A.Hi = uint64_t(f / p64);
	A.Lo = uint64_t(f - double(A.Hi) * p64);
}

// Floating point version
void SqMod(inout uint128 A, uint128 Q, bool doshift, double qinv) {
	uint256 X, Y;
	uint128 D;

	Sq256(A, X);
	if (doshift) {
		Lsh(X);
	}

	int i = 0; // limit to 10, in case we have a bug, don't want to get stuck...

	// Using floating point, take a guess at a number D such that we could subtract D*Q to leave our remander.
	// Always guess D a little low, and refine our guess as we get closer.
	// normally takes 2 passes.
	while (i < 10 && Cmp(X, Q) > 0) {

		double x = toF(X);
		fto128(x*qinv, D);
		if (Zero(D)) {
			D.Lo = 1;
		}		
		Mul256(D, Q, Y);

		Sub(X, Y);
		i++;
	}
	if (i > 3) {Debug[1]++;}
	A = X.L;
}
// Floating point version
void SqMod9(inout uint128 A, uint128 Q, bool doshift, double qinv) {
	uint192 X, Y;
	uint128 D;

	Sq192(A, X);
	if (doshift) {
		Lsh(X);
	}

	int i = 0; // limit to 10, in case we have a bug, don't want to get stuck...

	// Using floating point, take a guess at a number D such that we could subtract D*Q to leave our remander.
	// Always guess D a little low, and refine our guess as we get closer.
	// normally takes 2 passes.
	while (i < 10 && Cmp(X, Q) > 0) {

		double x = toF(X);
		fto128(x*qinv, D);
		if (Zero(D)) {
			D.Lo = 1;
		}		
		Mul192(D, Q, Y);

		Sub(X, Y);
		i++;
	}
	if (i > 3) {Debug[1]++;}
	A = X.L;
}


bool tf(uint64_t k, uint64_t p, int top) {
	uint128 sq, q;
	multiply64to128(k, p, q);
	Lsh(q);
	Inc(q);

	// Make our 1/q just a tiny bit too small, so we don't over estimate,
	// but not so small as to need extra passes.
	double qinv = 0.9999999999999 / toF(q);

	// Do the TF math: Starting with 1, repeatedly square,
	//  remove the top bit of the exponent and if 1 multiply squared value by 2,
	//  then compute mod Q.
	sq.Lo = 1; sq.Hi = 0;
	for (int b = top; b >= 0; b--) {
		bool bb = (p & (1l << b)) != 0;
		SqMod9(sq, q, bb, qinv);
	}
	// If the result is 1, then we found a factor.
	return sq.Lo == 1 && sq.Hi == 0;
}

//
// We want to know if Q=2*P*K+1 might be prime.  Test it with some small primes to determine if it is composite.
// We would test Q == 0 mod N, but Q is too big for uint64.  So instead we test (((2*P)modN * KmodN) + 1) == 0 modN
//

bool sieve(uint64_t k) {
	uint  r;
	const uint p2 = uint(P * 2);

	r = (((p2 % 13) * uint(k % 13)) +1) % 13;	if (r == 0) {return false;}
	r = (((p2 % 17) * uint(k % 17)) +1) % 17;	if (r == 0) {return false;}
	r = (((p2 % 19) * uint(k % 19)) +1) % 19;	if (r == 0) {return false;}
	r = (((p2 % 23) * uint(k % 23)) +1) % 23;	if (r == 0) {return false;}
	r = (((p2 % 29) * uint(k % 29)) +1) % 29;	if (r == 0) {return false;}
	r = (((p2 % 31) * uint(k % 31)) +1) % 31;	if (r == 0) {return false;}
	r = (((p2 % 37) * uint(k % 37)) +1) % 37;	if (r == 0) {return false;}
	r = (((p2 % 41) * uint(k % 41)) +1) % 41;	if (r == 0) {return false;}
	r = (((p2 % 43) * uint(k % 43)) +1) % 43;	if (r == 0) {return false;}
	r = (((p2 % 47) * uint(k % 47)) +1) % 47;	if (r == 0) {return false;}

	r = (((p2 % 53) * uint(k % 53)) +1) % 53;	if (r == 0) {return false;}
	r = (((p2 % 59) * uint(k % 59)) +1) % 59;	if (r == 0) {return false;}
	r = (((p2 % 61) * uint(k % 61)) +1) % 61;	if (r == 0) {return false;}
	r = (((p2 % 67) * uint(k % 67)) +1) % 67;	if (r == 0) {return false;}
	return true;

	r = (((p2 % 71) * uint(k % 71)) +1) % 71;	if (r == 0) {return false;}
	r = (((p2 % 73) * uint(k % 73)) +1) % 73;	if (r == 0) {return false;}

	r = (((p2 % 79) * uint(k % 79)) +1) % 79;	if (r == 0) {return false;}
	r = (((p2 % 83) * uint(k % 83)) +1) % 83;	if (r == 0) {return false;}
	r = (((p2 % 89) * uint(k % 89)) +1) % 89;	if (r == 0) {return false;}
	r = (((p2 % 97) * uint(k % 97)) +1) % 97;	if (r == 0) {return false;}

	r = (((p2 % 101) * uint(k % 101)) +1) % 101;	if (r == 0) {return false;}
	r = (((p2 % 103) * uint(k % 103)) +1) % 103;	if (r == 0) {return false;}
	r = (((p2 % 107) * uint(k % 107)) +1) % 107;	if (r == 0) {return false;}
	r = (((p2 % 109) * uint(k % 109)) +1) % 109;	if (r == 0) {return false;}
	r = (((p2 % 113) * uint(k % 113)) +1) % 113;	if (r == 0) {return false;}

	return true;
}
bool sieve3(uint64_t k) {
	uint  r;
	const uint p2 = uint(P * 2);

	r = 1;
	r *= (((p2 % 13) * uint(k % 13)) +1) % 13;
	r *= (((p2 % 17) * uint(k % 17)) +1) % 17;
	r *= (((p2 % 19) * uint(k % 19)) +1) % 19;
	r *= (((p2 % 23) * uint(k % 23)) +1) % 23;
	r *= (((p2 % 29) * uint(k % 29)) +1) % 29;
	r *= (((p2 % 31) * uint(k % 31)) +1) % 31;
	r *= (((p2 % 37) * uint(k % 37)) +1) % 37;
	r *= (((p2 % 41) * uint(k % 41)) +1) % 41;
	r *= (((p2 % 43) * uint(k % 43)) +1) % 43;
	r *= (((p2 % 47) * uint(k % 47)) +1) % 47;
	r *= (((p2 % 53) * uint(k % 53)) +1) % 53;
	r *= (((p2 % 59) * uint(k % 59)) +1) % 59;
	r *= (((p2 % 61) * uint(k % 61)) +1) % 61;
	r *= (((p2 % 67) * uint(k % 67)) +1) % 67;

	return r != 0;
}
void init(uint k) {

	// Use 4620 threads to initialize this table in parallel.
	if (k < 4620) {
		for (uint n = 0; n < 4620; n++) {
			uint q = 2 * n * k + 1;
			if (((q&7) == 3) || ((q&7) == 5) || (q%3 == 0) || (q%5 == 0) || (q%7 == 0) || (q%11 == 0)) {
				k4620[n][k] = 0;
			} else {
				k4620[n][k] = 1;
			}
		}
	}
}
void main() {
	// Which thread are we?

	uint I = gl_GlobalInvocationID.x;
	// When called with Init == 0, we need to initialize ourselves and return.
	if (Init == 0) {
		init(I);
		return;
	}

	const uint pm60 = uint(P % 4620l);
	//const uint pm60 = uint(P % 60l);
	const uint p2 = uint(P * 2);
	//const uint p2u = uint(p2);
	const uint64_t p = P;
	uint64_t klist[NK];
	uint64_t kbase = K + I * NK;  // our chunk of k-values

	// we start with NK - k-values to test, first loop will remove 80%,
	// the next loops will remove more, for about about 95% total.
	// leaving a short list to test further
	// the first loop uses a matrix from the cpu to eliminate p,k combinations that produce q=2pk+1,
	// that are divisible by a few small primes.
	int kl = 0;
	for (uint64_t k = kbase; k < kbase + NK; k++) {
		uint km = uint(k%4620l);

		if (k4620[pm60][km] == 1)
		{
			klist[kl++] = k;
		}
	}

	// shorten the list by sking sieve() to check a range of small primes.
	// The stage after this is fast enough that the time taken to seive is almost not worth it.
	int kl2 = kl;
	kl = 0;
	for (int i = 0; i < kl2; i++) {
		uint64_t k = klist[i];

		if (sieve(k))
		{
			klist[kl++] = k;
		}
	}
	if (I == 0) {
	       	Debug[0] = kl;  // just for debugging
	}
	//return;
	// kl should be about 0.06*NK to about 0.1*NK at this point.
	int top = int(findMSB((p)));
	for (int i = 0; i < kl; i++) {
		uint64_t k = klist[i];
		if (tf(k, p, top)) {
			Found = k;
		}
	}
}
