#version 460
//#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_gpu_shader_int64 : enable
#extension GL_EXT_debug_printf : enable
//#extension GL_KHR_shader_subgroup_vote : enable
//#extension GL_EXT_shader_explicit_arithmetic_types_int8 : enable
//#extension GL_EXT_shader_explicit_arithmetic_types_int16 : enable
//#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable


//
// compile this file with: glslangValidator --target-env vulkan1.3 -V tf.comp
//

// each thread will consider this many k values
#define NK 200

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) buffer buf
{
	uint64_t    P;       // input from CPU side
	uint64_t    K;       // base K input from CPU side
	uint64_t    Found;   // output to tell the CPU we found a K resulting in a factor
	uint64_t    Err;     // output only used for debugging
	uint        k4620[4620][4620];
};




struct uint128 {
	uint64_t Hi, Lo;
};
struct uint96 {
	uint H, M, L;
};
void Set(inout uint96 A, uint128 B) {
	A.L = uint(B.Lo & 0xfffffffful);
	A.M = uint(B.Lo >> 32);
	A.H = uint(B.Hi & 0xfffffffful);
}

void Lsh(inout uint96 A) {
	uint c1 = A.L & (1u << 31);
	uint c2 = A.M & (1u << 31);
	A.L <<= 1;
	A.M <<= 1;
	A.H <<= 1;
	A.M |= c1 >> 31;
	A.H |= c2 >> 31;
}
void Lsh(inout uint128 A) {
	uint64_t c = A.Lo & (uint64_t(1) << 63);
	A.Lo <<= 1;
	A.Hi <<= 1;
	A.Hi |= c >> 63;
}

void Rsh(inout uint96 A) {
	uint b1 = A.H & 1u;
	uint b2 = A.M & 1u;
	A.H >>= 1;
	A.M >>= 1;
	A.M |= b1 << 31;
	A.L >>= 1;
	A.L |= b2 << 31;
}
void Rsh(inout uint128 A) {
	uint64_t b = A.Hi & 1l;
	A.Hi >>= 1;
	A.Lo >>= 1;
	A.Lo |= b << 63;
}
int Cmp(uint96 A, uint96 B) {
	if (A.H > B.H) {return 1;}
	if (A.H < B.H) {return -1;}
	if (A.M > B.M || (A.M == B.M && A.L > B.L)) {return 1;}
	if (A.M < B.M || (A.M == B.M && A.L < B.L)) {return -1;}
	return 0;
}
int Cmp(uint128 A, uint128 B) {
	if (A.Hi > B.Hi || (A.Hi == B.Hi && A.Lo > B.Lo)) {return 1;}
	if (A.Hi < B.Hi || (A.Hi == B.Hi && A.Lo < B.Lo)) {return -1;}
	return 0;
}
void Inc(inout uint96 A) {
	A.L += 1;
	if (A.L == 0) {
		A.M += 1;
		if (A.M == 0) {
			A.H += 1;
		}
	}
}
void Inc(inout uint128 A) {
	A.Lo += 1;
	if (A.Lo == 0) {
		A.Hi += 1;
	}
}
void Sub(inout uint96 A, uint96 B) {
	uint x = A.L - B.L;
	uint C = 0;
	if (x > A.L) {C++;}
	A.L = x;
	x = A.M - (B.M + C);
	C = 0;
	if (x > A.M) {C++;}
	A.M = x;
	A.H -= B.H + C;
}
void Sub(inout uint128 A, uint128 B) {
	uint64_t x = A.Lo - B.Lo;
	uint64_t C = (((x & B.Lo) & 1l) + (B.Lo >> 1) + (x >> 1)) >> 63;
	A.Hi = A.Hi - (B.Hi + C);
	A.Lo = x;
}
void Add(inout uint96 A, uint96 B) {
	uint x = A.L + B.L;
	uint C = 0;
	if (x < A.L) {C++;}
	A.L = x;
	x = A.M + B.M + C;
	C = 0;
	if (x < A.M) {C++;}
	A.M = x;
	A.H += B.H + C;
}
void Add(inout uint128 A, uint128 B) {
	uint64_t x = A.Lo + B.Lo;
	uint64_t C = 0;
	if (x < A.Lo) {C++;}
	A.Hi = A.Hi + (B.Hi + C);
	A.Lo = x;
}
bool Zero(uint96 A) {
	return (A.L | A.M | A.H) == 0;
}
bool Zero(uint128 A) {
	return A.Lo == 0 && A.Hi == 0;
}
//
// Only used to compute Q = 2*P*K+1 for each K, so not a performance hit.
// XXX: need to create multiply64to96
//
void multiply64to128(uint64_t lhs, uint64_t rhs, inout uint128 r) {

	/* First calculate all of the cross products. */
	uint64_t lo_lo = (lhs & 0xFFFFFFFFul) * (rhs & 0xFFFFFFFFul);
	uint64_t hi_lo = (lhs >> 32)        * (rhs & 0xFFFFFFFFul);
	uint64_t lo_hi = (lhs & 0xFFFFFFFFul) * (rhs >> 32);
	uint64_t hi_hi = (lhs >> 32)        * (rhs >> 32);

	/* Now add the products together. These will never overflow. */
	uint64_t cross = (lo_lo >> 32) + (hi_lo & 0xFFFFFFFFul) + lo_hi;
	uint64_t upper = (hi_lo >> 32) + (cross >> 32)        + hi_hi;

	r.Hi = upper;
	r.Lo = (cross << 32) | (lo_lo & 0xFFFFFFFFul);
}
//
// This is fairly fast, for TF purposes, each for loop does 0, 1 or maybe sometimes 2 passes only
//
void Mod(inout uint128 A, uint128 B) {
	uint128 X, A2;
	X.Hi = B.Hi;
	X.Lo = B.Lo;
	A2.Lo = A.Lo;
	A2.Hi = A.Hi;
	Rsh(A2);

	while (Cmp(X, A2) <= 0) {
	        Lsh(X);
	}
	while (Cmp(A, B) >= 0) {
		if (Cmp(A, X) >= 0) {
			Sub(A, X);
		}
		Rsh(X);
	}
}
void Mod(inout uint96 A, uint96 B) {
	uint96 X, A2;
	X = B;
	A2 = A;
	Rsh(A2);

	while (Cmp(X, A2) <= 0) {
	        Lsh(X);
	}
	while (Cmp(A, B) >= 0) {
		if (Cmp(A, X) >= 0) {
			Sub(A, X);
		}
		Rsh(X);
	}
}
void ModLsh(inout uint96 A, uint96 B) {
	uint96 X, A2;
	X = B;
	A2 = A;
	//Rsh(A2);
	Lsh(A);

	while (Cmp(X, A2) <= 0) {
	        Lsh(X);
	}
	while (Cmp(A, B) >= 0) {
		if (Cmp(A, X) >= 0) {
			Sub(A, X);
		}
		Rsh(X);
	}
}
//
// Calculate A^2 mod Q, using no more than 128 bits.  This is slow, but easy to debug.
// Use this to compare with results of faster implementations.
//
void SqMod(inout uint128 A, uint128 Q) {
	uint128 a, b, r;
	r.Lo = 0; r.Hi = 0;
	a = A;
	b = A;

	// A is already mod Q
	while (!Zero(b)) {
		if ((b.Lo & 1) != 0) {
			Add(r, a);
			Mod(r, Q);
		}
		Lsh(a);
		Mod(a, Q);
		Rsh(b);
	}
	A = r;
}
void SqMod(inout uint96 A, uint96 Q) {
	uint96 a, b, r;
	r.L = 0; r.M = 0; r.H = 0;
	a.L = A.L; a.M = A.M; a.H = A.H;
	b.L = A.L; b.M = A.M; b.H = A.H;

	// A is already mod Q
	while (!Zero(b)) {
		if ((b.L & 1) != 0) {
		       	Add(r, a);
			Mod(r, Q);
		}
		//Lsh(a);
		ModLsh(a, Q);
		Rsh(b);
	}
	A.L = r.L;
	A.M = r.M;
	A.H = r.H;
}
// small primes for sieve()
const uint sp[560] = {11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093};

//
// We want to know if Q=2*P*K+1 might be prime.  Test it with some small primes to determine if it is composite.
// We would test Q == 0 mod N, but Q is too big for uint64.  So instead we test (((2*P)modN * KmodN) + 1) == 0 modN
//
const int ntestprimes = 300;  // tweak as needed
bool modkpn(uint p2, uint64_t k, uint N) {
	uint64_t r = (((p2 % N) * (k % N)) +1) % N;
	return r == 0;
}
bool sieve(uint p2, uint64_t k) {

	for (int i = 0; i < ntestprimes; i++) {
		uint N = sp[i];
		//uint  r = (((p2 % N) * uint(k % N)) +1) % N;
		if (modkpn(p2, k, N)) {
			return false;
		}
	}
	return true;
}

bool tf96(uint64_t k, uint64_t p, int top) {
	uint128 q;
	uint96 sq9, q9;
	multiply64to128(k, p, q);
	Lsh(q);
	Inc(q);
	Set(q9, q);

	// Do the TF math: Starting with 1, repeatedly square,
	//  remove the top bit of the exponent and if 1 multiply squared value by 2,
	//  then compute mod Q.
	sq9.L = 1; sq9.M = 0; sq9.H = 0;
	for (int b = top; b >= 0; b--) {
		bool bb = (p & (1l << b)) != 0;
		if (bb) {
			Lsh(sq9);
		}
		SqMod(sq9, q9);
	}
	// If the result is 1, then we found a factor.
	return sq9.L == 1 && sq9.H == 0 && sq9.M == 0;
}
bool tf(uint64_t k, uint64_t p, int top) {
	uint128 sq, q;
	multiply64to128(k, p, q);
	Lsh(q);
	Inc(q);

	// Do the TF math: Starting with 1, repeatedly square,
	//  remove the top bit of the exponent and if 1 multiply squared value by 2,
	//  then compute mod Q.
	// 128bit version seems to be faster...
	sq.Lo = 1; sq.Hi = 0;
	for (int b = top; b >= 0; b--) {
		bool bb = (p & (1l << b)) != 0;
		if (bb) {
			Lsh(sq);
		}
		SqMod(sq, q);
	}
	// If the result is 1, then we found a factor.
	return sq.Lo == 1 && sq.Hi == 0;
}

void main() {
	// Which thread are we?

	uint I = gl_GlobalInvocationID.x;

	const uint pm60 = uint(P % 4620l);
	const uint64_t p2 = P * 2;
	const uint p2u = uint(p2);
	const uint64_t p = P;
	uint64_t klist[NK/2];
	uint64_t klist2[NK/2];
	uint64_t kbase = K + I * NK;  // our chunk of k-values


	// we start with NK - k-values to test, this will remove about 93%,
	// leaving a short list to test further
	int kl = 0;
	for (uint64_t k = kbase; k < kbase + NK; k++) {
		uint km = uint(k%4620l);
		if (k4620[pm60][km] == 1)
		{
			klist[kl++] = k;
		}
	}
	int kl2 = kl;
	kl = 0;
	for (int i = 0; i < kl2; i++) {
		uint64_t k = klist[i];
		if (sieve(p2u, k)) {
			klist[kl++] = k;
		}
	}
	if (I == 0) {
		Err = kl;  // just for debugging
	}

	int top = int(findMSB((p)));
	for (int i = 0; i < kl; i++) {
		uint64_t k = klist[i];
		if (tf96(k, p, top)) {
			Found = k;
		}
	}
}
